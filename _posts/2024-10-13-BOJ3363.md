---
layout: post
title:  "BOJ 3363 동전 [Gold V]"
summary: "BOJ 3363 Solve"
date: '2024-10-13 19:00:00 +0900'
category: blog
---
<div style = "margin:2em">

<h1>BOJ 3363 동전 [Gold V]</h1>
<h2>문제</h2>
<a href="https://www.acmicpc.net/problem/3363">https://www.acmicpc.net/problem/3363</a>
<br/>

![img 2024-10-13 182929](https://github.com/hikari0102/hikari0102.github.io/blob/master/assets/images/img%202024-10-13%20182929.png?raw=true){: .align-center} <br/>

<h3>예제 입력</h3>

~~~Text
1 2 3 10 > 4 5 6 11
1 2 3 11 > 7 8 9 10
1 4 7 10 < 2 5 8 12
~~~

<h3>예제 출력</h3>

~~~Text
2+
~~~

<h2>문제 분석</h2>

<div class="notice"  markdown="1">
<ul>
<li>12개의 동전 중 무게가 다른 것만 무게가 다르고 나머지는 같은 무게를 가진다.</li>
<li>조건 3개를 가지고 찾을 수 있다면 이상 있는 동전의 번호와 가벼운지 무거운지를 구분한다.</li>
<li>조건 3개가 모순이 된다면 impossible를 출력한다.</li>
<li>조건 3개에서 이상 있는 동전이 발견이 되었으나, 번호나 무거운지 가벼운지를 판단을 할 수 없는 경우에는 indefinite를 출력한다.</li>
</ul>
</div>
<s>처음에 1번 동전은 무게 1, 2번 동전은 무게 2... 12번 동전은 무게 12 이런거인줄</s>  
<br/>
<br/>
이 문제에서 가능한 경우의 수는 동전이 총 12개, 이상의 경우가 2개(무거운가? 가벼운가?) 즉, 12 * 2 = 24가지이다. 시간제한이 1초이므로, 24가지의 상황에 대해서 조건 3개를 모두 테스트 해봐도 넉넉한 시간이다. 따라서 <b>24가지의 상황을 모두 테스트 해보는 브루트 포스로 문제를 해결 할 수 있다.</b> 이때 24가지의 경우가 모두 3개의 조건을 만족하지 못하는 경우는 모순이다. 즉, impossible를 출력하면 된다. 반대로 24가지의 경우중 3개의 조건을 만족하는 경우가 2가지 이상이면 둘 중 무엇인지 판단을 할 수 없다는 뜻이므로 indefinite이다.

<h2>코드</h2>

~~~C++
#include <stdio.h>

// https://www.acmicpc.net/problem/3363

int main() {
    int cond[3][9]; // 0 ~ 3 => 왼쪽, 4 ~ 7 => 오른쪽, 8 => 가운데 부등호 (1 : >, 0 : =, -1 : <)
    for(int i = 0; i < 3; i++) {
        char c[2];
        for(int j = 0; j < 4; j++)
            scanf("%d", &cond[i][j]);
        scanf("%s", c);
        if(c[0] == '>')
            cond[i][8] = 1;
        else if(c[0]  == '<')
            cond[i][8] = -1;
        else
            cond[i][8] = 0;
        for(int j = 4; j < 8; j++)
            scanf("%d", &cond[i][j]);
    } // 입력
    int ans[25][2], cnt = 0; // 정답인 것들 저장할 배열 및 정답 개수
    for(int i = 1; i <= 12; i++) { // 구슬 번호
        for(int j = 0; j < 2; j++) { // 가벼우면 0 무거우면 1
            int chk = 0; // 만족하는 조건의 개수
            for(int k = 0; k < 3; k++) {
                int left_sum = 0, right_sum = 0;
                for(int l = 0; l < 4; l++) {
                    if(cond[k][l] != i)
                        left_sum += 2;
                    else {
                        if(j == 0)
                            left_sum += 1;
                        else
                            left_sum += 3;
                    }
                } // 부등호 좌변 계산 (무거우면 3, 일반은 2, 가벼우면 1로 계산)
                for(int l = 4; l < 8; l++) {
                    if(cond[k][l] != i)
                        right_sum += 2;
                    else {
                        if(j == 0)
                            right_sum += 1;
                        else
                            right_sum += 3;
                    }
                } // 부등호 우변 계산 (무거우면 3, 일반은 2, 가벼우면 1로 계산)
                if((cond[k][8] == -1 && left_sum < right_sum) || (cond[k][8] == 0 && left_sum == right_sum) 
                || (cond[k][8] == 1 && left_sum > right_sum)) // 조건에 맞는지 체크
                    chk++;
            }
            if(chk == 3) { // 3개 다 일치하면 정답에 저장
                ans[cnt][0] = i;
                ans[cnt][1] = j;
                cnt++;
            }
        }
    }
    if(cnt == 1) { // 정답개수 1개면 출력
        if(ans[0][1] == 0)
            printf("%d-\n", ans[0][0]);
        else
            printf("%d+\n", ans[0][0]);
    }
    else if(cnt == 0) // 정답 없으면 impossible
        printf("impossible\n");
    else // 정답 여러개면 indefinite
        printf("indefinite\n");
}
~~~


</div>
